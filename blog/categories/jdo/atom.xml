<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Jdo | My Tech Blog]]></title>
  <link href="http://andresesfm.github.io/blog/categories/jdo/atom.xml" rel="self"/>
  <link href="http://andresesfm.github.io/"/>
  <updated>2014-08-20T09:15:23-06:00</updated>
  <id>http://andresesfm.github.io/</id>
  <author>
    <name><![CDATA[Andres Aguilar]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Objectify's OnLoad Can Be Tricky]]></title>
    <link href="http://andresesfm.github.io/blog/2014/08/01/objectify-onload-can-be-tricky/"/>
    <updated>2014-08-01T08:18:30-06:00</updated>
    <id>http://andresesfm.github.io/blog/2014/08/01/objectify-onload-can-be-tricky</id>
    <content type="html"><![CDATA[<p>When creating a <code>Ref&lt;?&gt;</code> to another object can be tricky since, here is the scenario:</p>

<p>I have an Entity <code>UserPost</code> that has a reference to <code>UserProfile</code> like so:
&#8220;`java
@Entity
public class UserPost {
    @Id
    public Long id;</p>

<pre><code>@JsonIgnore
@Index
@Load(All.class)
private Ref&lt;UserProfile&gt; user;

@Ignore
public String userNickname;

@OnLoad
public void onLoad(){
    if(user!=null){
        UserProfile userProfile = user.get();
        if (userProfile != null) {
            this.userNickname = userProfile.userNickname;
        }
    }
}

public void setUserRef(Ref&lt;UserProfile&gt; userRef) {
    this.user = userRef;
}

public static class All {
}
</code></pre>

<pre><code>The problem then was that `userNickname` was null sometimes even when `user` was being set. After some trial and error I found this post [Google Groups](https://groups.google.com/forum/#!topic/objectify-appengine/TT27QyLGYPI) where they mention the fact that @OnLoad only gets called when the Entity is not found in the session. 

My solution: call onLoad directly when setting the reference. That makes that instance to be usable right away. But at the same it will be loaded when needed.
</code></pre>

<p>@Entity
public class UserPost {
    @Id
    public Long id;</p>

<pre><code>@JsonIgnore
@Index
@Load(All.class)
private Ref&lt;UserProfile&gt; user;

@Ignore
public String userNickname;

@OnLoad
public void onLoad(){
    if(user!=null){
        UserProfile userProfile = user.get();
        if (userProfile != null) {
            this.userNickname = userProfile.userNickname;
        }
    }
}

public void setUserRef(Ref&lt;UserProfile&gt; userRef) {
    this.user = userRef;
    onLoad();
}

public static class All {
}
</code></pre>

<p>&#8220;`</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Objectify Alongside JDO]]></title>
    <link href="http://andresesfm.github.io/blog/2014/07/31/using-objectify-alongside-jdo/"/>
    <updated>2014-07-31T00:00:00-06:00</updated>
    <id>http://andresesfm.github.io/blog/2014/07/31/using-objectify-alongside-jdo</id>
    <content type="html"><![CDATA[<p>When migrating from JDO to Objectify, It&rsquo;s often the case where you need them to co-exist during the transition. Here is my case:</p>

<p>Suppose that you have an entity called <code>UserProfile</code> defined as follows:
&#8220;`java
@PersistenceCapable
public class UserProfile implements Serializable {</p>

<pre><code>@PrimaryKey
@Persistent(valueStrategy = IdGeneratorStrategy.IDENTITY)
private Key key;
@Persistent
public String photoPath;
@Persistent
public String userNickname;
</code></pre>

<p>}</p>

<pre><code>A pretty normal JDO-annotated entity. Now reading on-line people say that Ofy and JDO can co-exist. So I tried something like:
</code></pre>

<p>@Entity
@PersistenceCapable
public class UserProfile implements Serializable {
    @Ignore
    @PrimaryKey
    @Persistent(valueStrategy = IdGeneratorStrategy.IDENTITY)
    private Key key;</p>

<pre><code>@Id
public Long oid;

@Persistent
public String photoPath;
@Indexed
@Persistent
public String userNickname;
</code></pre>

<p>}</p>

<p>&#8220;`</p>

<p>Notice that I&rsquo;m explicitly ignoring the key. However I get the following vey cryptic exception:</p>

<pre><code>
java.lang.NoClassDefFoundError: Could not initialize class com.x.model.OfyService
</code></pre>


<p>The solution I found was to leave UserProfile intact and create a new class:
&#8220;`java
@Entity(name=&ldquo;UserProfile&rdquo;)
public class UserProfileOfy implements Serializable {
    @Id
    public Long oid;</p>

<pre><code>public String photoPath;
@Indexed
public String userNickname;
</code></pre>

<p>}</p>

<p><code>``
Notice the</code>name<code>parameter in the</code>@Entity` annotation.</p>
]]></content>
  </entry>
  
</feed>
